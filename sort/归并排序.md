# 归并排序

将数组分为有序的两部分

假设 a = [1,3,5] b = [2,4,6] 如何合并 a，b ？

答案是 先新建一个 c = [];

拿出 a 中最小的和 b 中最小的比较得到最小的数

c.push( minNum )

然后将最小的数移出队列 或者将指针后移；

依次循环即可

## 思路

将数组一分为二递归地让他们有序

## demo
```js
function mergeSort(arr, middle = Math.floor(arr.length / 2) || 1, temp = []){
  if(arr.length>2){
    const leftArr = mergeSort(arr.slice(0,middle));
    const rightArr = mergeSort(arr.slice(middle));
    while(leftArr.length){
      if(leftArr[0]>rightArr[0]){
        temp.push(rightArr.shift())
      }else{
        temp.push(leftArr.shift())
      }
    }
    while(rightArr.length){
      temp.push(rightArr.shift())
    }
    return temp;
  } else if(arr.length === 2) {
    if(arr[0]>arr[1]){
      const tempNum = arr[0];
      arr[0] = arr[1];
      arr[1] = tempNum;
      return arr;
    } else {
      return arr; 
    }
  } else {
    return arr;
  }
}
```

## 考虑内存的归并排序

```js
function mergePass(arr = [], temp = new Array(arr.length), N = arr.length, length = 1){
  let t;
  for (t = 0; Math.pow(2,t) < N; t++, length *= 2) {
    const even = t%2 === 0;
    for (let i = 0;  i < N; i += 2 * length) {
      merge(even ? arr : temp, even ? temp : arr, i, i + length < N ? i + length : i, i < N - 2 * length ? i + (2 * length) : N );
    }
  }
  merge(arr, temp, 0, Math.pow(2,t-1), N);
  return temp;
}


function merge(arr, temp, left, middle, right){
  const leftEnd = middle - 1;
  while (left <= leftEnd && middle < right) {
    if (arr[left] > arr[middle]) {
      temp[left + middle - leftEnd -1] = arr[middle++];
    } else {
      temp[left + middle - leftEnd -1] = arr[left++];
    }
  }
  while(left > leftEnd && middle < right){
    temp[left + middle - leftEnd -1] = arr[middle++];
  }
  while(left <= leftEnd && middle >= right){
    temp[left + middle - leftEnd -1] = arr[left++];
  }
}
```